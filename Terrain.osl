// License and stuff missing, and cant remember, so will come a bit later :)

float fract ( float x )
{
	return x - floor (x);
}

vector fract (vector x )
{
	return x - floor (x);
}

float random (vector _st){
    return fract(sin(dot(_st,vector(12.9898,78.233,0)))*43758.5453123);
}


float Noise ( vector _st) {
    vector i = floor(_st);
    vector f = fract(_st);
    float a = random(i);
    float b = random(i + vector(1.0, 0.0,0));
    float c = random(i + vector(0.0, 1.0,0));
    float d = random(i + vector(1.0, 1.0,0));
    vector U = f * f * (3.0 - 2.0 * f);

    return mix(a, b, U[0]) +
            (c - a)* U[1] * (1.0 - U[0]) +
            (d - b) * U[0] * U[1];
}

float fbm ( vector _st, int Octaves) {
    float V = 0.0;
    float a = 0.5;
    vector shift = vector(100.0);
    matrix rot = matrix(cos(0.5), sin(0.5),0,0, -sin(0.5), cos(0.5),0,0,0,0,0,0,0,0,0,0);
		
    for (int i = 0; i < Octaves; ++i) {
        V += a * Noise(_st);
        _st = transform(rot,_st * 2.0 + shift);
        a *= 0.5;
    }
    return V;
}

shader Terrain (
	
	point Po =P,
	float Time = 0,
	int Octaves = 20,
	output vector Out = 0,
)
{
    vector st = Po;
    vector Color = vector(0.0);
    vector q = vector(0.);
    q[0] = fbm( st + 0.00*Time,Octaves);
    q[1] = fbm( st + vector(1.0),Octaves);
    vector r = vector(0.);
    r[0] = fbm( st + 1.0*q + vector(1.7,20.2,0)+ 0.02*Time,Octaves );
    r[1] = fbm( st + 1.0*q + vector(18.3,2.8,0)+ 0.09*Time,Octaves);
    float f = fbm(st+r,Octaves);
    f= pow(f,0.35);
    Color = mix(vector(0.0,0.1,0.0),
                vector(0.0,0.0,0.0),
                clamp((f*f)*4.0,0.0,1.0));

    Color = mix(Color,
                vector(0.0,0.0,0.0),
                clamp(length(q),0.0,1.0));

    Color = mix(Color,
                vector(0.666667,1,1),
                clamp(length(r[0]),0.0,1.0));
  
	f = (f*f*f+0.1*f*f+.5*f);
	f+=cos(f*Time*0.8);
	f+=fract(f/Time);
	f-=pow(f,3.0);
    Out = vector(f,f,f);
}