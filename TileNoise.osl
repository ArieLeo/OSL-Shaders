// TileNoise.osl
// Version 0.1c 
// Compiled 8.4.2019 by Mads Dr√∏schler
// LICENSE: CC 3.0

// This Perlin-Worley shader tiles seamlessly over UV borders.

// to-do:
// - Add all relevant Medatdata.
// - branch shuffle axis from constants in line 92. curerntly only 1 axis hooked up.
// - Check for proper color/vector/point struct logic through code.
// - Add a shuffle so user can get a completly new and random seed with a single click
// - Integrate Time to fbm5 for turbulence, right now it just drives general .y offset.
// - Wire up multiple internal controls to UI.
// - Potentially make a switch for tiling to be ON or OFF? ( requires some internal IF's in the hashes and the wrap also needs a second ruleset.



float fract (float x)
{
	return x-floor(x);
}

vector fract (vector x)
{
	return x-floor(x);
}

float Hash( output vector p, float scale)
{
	p = mod(p, scale);
	
	return fract(sin(dot(p, vector(27.16, 38.90,0))) * 51.53);
}

float Hash2(output vector p, float scale)
{
	p = mod(p, scale);
	
	return fract(sin(dot(p, vector(27.15, 38.91, 49.20))) * 51.54);
}

float Noise(output vector p, float scale)
{
	vector f;
	p *= scale;
	f = fract(p);
    p = floor(p);
    f = f*f*(3.0-2.0*f);
    
    float res = mix(mix(Hash(p, 				 	 scale),
						Hash(p + vector(1.0, 0.0,0), scale), f[0]),
					mix(Hash(p + vector(0.0, 1.0,0), scale),
						Hash(p + vector(1.0, 1.0,0), scale), f[0]), f[1]);
    return res;
}

float Noise2(output vector p, float scale)
{
    vector f;
	p *= scale;	
	f = fract(p);
    p = floor(p);	
    f = f*f*(3.0-2.0*f);	
    
    float resA = mix(mix(Hash2(p + vector(0.0, 0.0, 0.0), scale),
						 Hash2(p + vector(1.0, 0.0, 0.0), scale), f[0]),
					 mix(Hash2(p + vector(0.0, 1.0, 0.0), scale),
					     Hash2(p + vector(1.0, 1.0, 0.0), scale), f[0]), f[1]);
    
    float resB = mix(mix(Hash2(p + vector(0.0, 0.0, 1.0), scale),
						 Hash2(p + vector(1.0, 0.0, 1.0), scale), f[0]),
					 mix(Hash2(p + vector(0.0, 1.0, 1.0), scale),
					   	 Hash2(p + vector(1.0, 1.0, 1.0), scale), f[0]), f[1]);
    
    return mix(resA,resB,f[2]);
}


float fBm5 (output vector p, output float intScale, output float amp)
{
	float f = 0.0;
    p = mod(p, intScale);
	
	for (int i = 0; i < 5; i++) {
		f += Noise2(p, intScale) * amp;
		amp *= .5;
		intScale *= 2.;
	}
    
	return min(f, 1.0);
}

vector hash3( output vector p, int shuffle )
{
    p = vector(dot(p,vector(127.1,shuffle,411.0)),
               dot(p,vector(269.5,183.3,120.0)),
               dot(p,vector(69.4,583.3,520.0))
              );
    
    return fract(sin(p)*18.54);
}


float wrap(float n, float period)
{
    return n >= 0.0 ? mod(n,period) : period + n;
}

vector voronoi( vector x, float per, int shuffle)
{
    vector n = floor( x );
    vector f = fract( x );
	vector m = vector( 8.0 );
	
    for( int k=-1; k<=1; k++ )
    for( int j=-1; j<=1; j++ )
    for( int i=-1; i<=1; i++ )
    
    {
        vector g = vector( float(i), float(j), float(k) );
        vector gn = n + g; 
        gn[0] = wrap(gn[0],per);
        gn[1] = wrap(gn[1],per);
        gn[2] = wrap(gn[2],per);
        vector o = hash3(gn,shuffle);
        vector  r = g - f + o;
		float d = dot( r, r );
        if( d<m[0] )
            m = vector( d, o[0],o[1] );
    }

    return vector( sqrt(m[0]), m[1]+m[2],0 );
}


float billows(output vector p, output float intScale, output float amp, int billowIter, int shuffle)
{
    float f = 0.0;
    p = mod(p, intScale);
	
	for (int i = 0; i < billowIter; i++) {
		vector voroset =voronoi(p * intScale, intScale,shuffle);
		f += voroset[0] * amp;
		amp *= .5;
		intScale *= 2.;
	}
    
	return min(f, 1.0);
}

shader TileNoise
[[ string help  = "Tilable Perlin Worley noise that blends over UV seams",
   string label = "TileNoise" ]]
( 

	point Po = P,
	int shuffle = 12345
	[[ string help = "A random number that gets scaled internally with 3 weights to get randomly generated startingpoints" ]]	
	, // currently only .y expand to all axis set up a constant that branches and scales differently. Line 93.
 	float Time = 0,
 	int billowIter = 3,
 	float billowScale = 4.0,
 	float billowAmp = 0.75,
 	float billowGamma = 1.0,
 	int noiseScale = 6,
 	float noiseAmp = 0.6,
 	float finalMix = 0.5,
 	float warpAmount = 16.0,
 	float Gamma = 2.2,
 	
 	output color Out = 0,
   
   )
{
	point uv = Po;
    uv[0] *= 1.7;
    
    point p = vector(uv[0],uv[1]+fract(Time),0.0);
    
    float billowScaleIN = billowScale;
    float billowAmpIN = billowAmp;
    float billowGammaIN = billowGamma;
    float noiseScaleIN = noiseScale;
    float noiseAmpIN = noiseAmp;
    float finalMixIN = finalMix;
    float warpAmountIN = 1.0/warpAmount;
    float bil = 1.0 - pow(billows(p,billowScaleIN,billowAmpIN,billowIter,shuffle),billowGamma);
    float per = fBm5(p+vector(bil * warpAmountIN),noiseScaleIN,noiseAmpIN);
   	float fin = mix(per,bil,finalMixIN);
	Out = vector(fin);
	Out = pow(Out,Gamma);
}